// test_camera.cpp
#include "camera.hpp"  // Your camera header
#include <iostream>
#include <iomanip>
#include "shapes.hpp"
#include "json_loader.hpp"
#include "acceleration.hpp"


void printArray(const std::array<float,3>& arr, const std::string& name) {
    std::cout << name << ": [" << arr[0] << ", " << arr[1] << ", " << arr[2] << "]" << std::endl;
}


void printHitInfo(const Hit& hit) {
    // Check if it's a valid hit by looking at 't' or 'shape'
    // Using numeric_limits requires including the <limits> header
    if (hit.shape == nullptr || hit.t == std::numeric_limits<float>::max()) {
        std::cout << "--- No Hit ---" << std::endl;
        return;
    }

    std::cout << "--- Hit Information ---" << std::endl;
    std::cout << "Intersection Point: ("
              << hit.intersection_point[0] << ", "
              << hit.intersection_point[1] << ", "
              << hit.intersection_point[2] << ")" << std::endl;
    std::cout << "Normal Vector:      ("
              << hit.normal[0] << ", "
              << hit.normal[1] << ", "
              << hit.normal[2] << ")" << std::endl;
    std::cout << "Distance (t):       " << hit.t << std::endl;

    // Assuming Shapes base class has a public 'type' member string
    // If not, you might need a virtual function like hit.shape->getType()
    if (hit.shape) {
        std::cout << "Shape Type:         " << hit.shape->type << std::endl;
        std::cout << "Shape Address:      " << hit.shape << std::endl; // For debugging
    } else {
        std::cout << "Shape Type:         Unknown (nullptr)" << std::endl;
    }
    std::cout << "-----------------------" << std::endl;
}

int main() {
    std::string scene_path = "/Users/ericzhang/Documents/Computer_graphics/Coursework/s2286795/ASCII/scene.json";
    
    // Test 1: Constructor and file reading
    std::cout << "=== Test 1: Loading Camera ===" << std::endl;
    Camera camera(scene_path);
   
    // Get the info of different shapes from the json file and create a vector of shapes*
    std::cout<< "=== Test 2: Loading Shapes ===" << std::endl;
    std::vector<std::unique_ptr<Shapes>> shape_list = load_shapes_from_json(scene_path);

    // get the raw pointer from the unique pointer generated by load_shapes_from_json
    std::vector<Shapes*> shape_list_raw;
    for (int i=0; i< shape_list.size(); i++){
        std::cout<< i<<"th object Type: "<<shape_list[i] -> type <<std::endl;
        Shapes* raw_ptr = shape_list[i].get();
        shape_list_raw.push_back(raw_ptr);
    }
    
    // Build the BVH for acceleration
    std::cout << "=== Test 3: Creating BVH for Acceleration ===" << std::endl;
    BVH* accelerator = new BVH(shape_list_raw);


    // get the raw pointer from the unique pointer generated by load_shapes_from_json
    auto resolution = camera.getResolution();
    int centerX = std::get<0>(resolution) / 2;
    int centerY = std::get<1>(resolution) / 2;
    auto ray_raw = camera.pixelToRay(std::make_tuple(centerX, centerY));
    Ray ray;
    ray.origin = std::get<0>(ray_raw); 
    ray.direction = std::get<1>(ray_raw); 
    // intersection testing

    std::cout << "=== Test 4: Intersection Testing ===" << std::endl;
    Hit closest_hit = accelerator -> intersect(ray, accelerator -> root);

    printHitInfo(closest_hit);
}